#include "commons.h"
#include "cuCommons.h"
#include "testCommons.h"

// README
// Due to performance constraints and ease of building, all __device__ code is located in a single file

__device__ void devPrintArray(int *dev, int n) {
  printf("[");
  for (int a = 0; a < n; a++) {
    printf("%d", dev[a]);
    if (a + 1 < n) printf(", ");
  }
  printf("]\n");
}

__device__ bool devAreNeighbors(const CuGraph &G, int a, int b) { return G.devMatrix[a * G.n + b]; }

__device__ int devGetFirstNeighbor(const CuGraph &G, int a) { return G.devFirstNeighbor[a]; }

__device__ int devGetNextNeighbor(const CuGraph &G, int a, int b) {
  int ret = G.devNextNeighbor[a * G.n + b];
  if (ret == -2) {
    assert("CUDA devGetNextNeighbor failed" == 0);
  }

  return ret;
}

__device__ bool devIsDistinctValues(int *path, int length) {
  for (int i = 1; i < length; i++) {
    for (int j = 0; j < i; j++) {
      if (path[i] == path[j]) return false;
    }
  }

  return true;
}

__device__ bool devIsAPath(const CuGraph &G, int *path, int length, bool isCycleOk = false,
                           bool areChordsOk = false) {
  if (length <= 0) return false;

  if (!devIsDistinctValues(path, length)) return false;

  for (int i = length - 1; i > 0; i--) {
    for (int j = 0; j < i; j++) {
      if (j == i - 1) {
        if (!devAreNeighbors(G, path[i], path[j])) return false;
      } else if (!areChordsOk) {
        if (isCycleOk && i == length - 1 && j == 0) continue;
        if (devAreNeighbors(G, path[i], path[j])) return false;
      }
    }
  }

  return true;
}

__device__ bool devIsAHole(const CuGraph &G, int *v, int lenV) {
  return lenV > 3 && devIsAPath(G, v, lenV, true, false) && devAreNeighbors(G, v[0], v[lenV - 1]);
}

__device__ void devPreparePathStart(int code, int *v, int lenV, int n) {
  int tmp = 0;

  while (tmp < lenV) {
    v[tmp] = code % n;
    code /= n;
    tmp++;
  }
}

__device__ bool devNextPathInPlace(const CuGraph &G, int *v, int &lenV, int lenPath, bool isCycleOk = false,
                                   bool areChordsOk = false) {
  if (lenPath <= 1) {
    assert("(DEV ERROR) Length of next path must be at least 2" == 0);
  }

  if (lenV > 0 && !devIsAPath(G, v, lenV, isCycleOk, areChordsOk)) {
    assert("(DEV ERROR) Input of devNextPath should be a path" == 0);
  }

  if (lenV == 0) {
    v[0] = 0;
    lenV = 1;
  }

  while (true) {
    if (v[lenV - 1] == -1) {
      lenV--;
      if (lenV == 1) {
        v[0]++;
        if (v[0] >= G.n) {
          lenV = 0;
          return;
        }
        continue;
      } else {
        v[lenV - 1] = devGetNextNeighbor(G, v[lenV - 2], v[lenV - 1]);
        continue;
      }
    }

    if (lenV < lenPath) {
      v[lenV] = devGetFirstNeighbor(G, v[lenV - 1]);
      lenV++;
      if (lenV == lenPath && devIsAPath(G, v, lenV, isCycleOk, areChordsOk))
        return;
      else
        continue;
    }

    do {
      v[lenV - 1] = devGetNextNeighbor(G, v[lenV - 2], v[lenV - 1]);
    } while (v[lenV - 1] != -1 && !devIsAPath(G, v, lenV, isCycleOk, areChordsOk));

    if (v[lenV - 1] == -1) continue;

    return;
  }
}

// # cu* portion (ran by host, uses __device__ code)

bool cuContainsHoleOfSize(const CuGraph &G, int size, context_t &context,
                          int maxThreads = _max_threads_to_run) {
  static const int max_size = 30;

  assert(max_size > size);

  int k = G.n;
  int kCounter = 1;
  while (k * G.n <= maxThreads && kCounter < size) {
    k *= G.n;
    kCounter++;
  }

  int *devOddHoleFound;
  CUCHECK(cudaMalloc(&devOddHoleFound, sizeof(int) * 1));

  typedef launch_params_t<256, 16> launch_t;

  auto f = [=] MGPU_DEVICE(int tid, int cta) {
    typedef typename launch_t::sm_ptx params_t;
    enum { nt = params_t::nt, vt = params_t::vt };

    int codeStart = ((cta * nt) + tid) * vt;

    for (int i = 0; i < vt; i++) {
      int id = codeStart + i;

      if (id >= k) return;

      int v[max_size];
      int lenV = kCounter;
      devPreparePathStart(id, v, kCounter, G.n);
      int mem = v[kCounter - 1];

      if (!devIsAPath(G, v, lenV, lenV == size)) continue;

      if (lenV < size) devNextPathInPlace(G, v, lenV, size, true);

      while (lenV == size && v[kCounter - 1] == mem) {
        if (devIsAHole(G, v, size)) {
          // devPrintArray(v, lenV);
          devOddHoleFound[0] = 1;
          return;
        }
        devNextPathInPlace(G, v, lenV, size, true);
      }
    }
  };

  cta_transform<launch_t>(f, k, context);
  context.synchronize();

  // transform(
  //     [=] MGPU_DEVICE(int id) {
  //       int v[max_size];
  //       int lenV = kCounter;
  //       devPreparePathStart(id, v, kCounter, G.n);
  //       int mem = v[kCounter - 1];

  //       if (!devIsAPath(G, v, lenV, lenV == size)) return;

  //       if (lenV < size) devNextPathInPlace(G, v, lenV, size, true);

  //       while (lenV == size && v[kCounter - 1] == mem) {
  //         if (devIsAHole(G, v, size)) {
  //           // devPrintArray(v, lenV);
  //           devOddHoleFound[0] = 1;
  //           return;
  //         }
  //         devNextPathInPlace(G, v, lenV, size, true);
  //       }
  //     },
  //     k, context);
  // context.synchronize();

  int oddHoleFound[1];
  CUCHECK(cudaMemcpy(oddHoleFound, devOddHoleFound, sizeof(int) * 1, cudaMemcpyDeviceToHost));
  context.synchronize();

  return oddHoleFound[0];
}

bool cuContainsOddHoleNaive(const CuGraph &G, context_t &context, int maxThreads = _max_threads_to_run) {
  for (int size = 5; size <= G.n; size += 2) {
    if (cuContainsHoleOfSize(G, size, context, maxThreads)) return true;
  }

  return false;
}

bool cuIsPerfectNaive(const Graph &G, context_t &context, int maxThreads = _max_threads_to_run) {
  CuGraph CG = CuGraph(G, context);
  CuGraph CCG = CuGraph(G.getComplement(), context);

  bool res =
      !cuContainsOddHoleNaive(CG, context, maxThreads) && !cuContainsOddHoleNaive(CCG, context, maxThreads);

  CG.deleteCuGraph();
  CCG.deleteCuGraph();

  context.synchronize();

  return res;
}