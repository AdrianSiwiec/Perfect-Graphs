#include "commons.h"
#include "cuCommons.h"
#include "cuOddHoles.h"

// README
// Due to performance constraints and ease of building, all __device__ code is located in a single file

// __device__ int get42() { return 42; }

__device__ void devPreparePathStart(int code, int len, int n, int *devPath) {
  int tmp = 0;

  while (tmp < len) {
    devPath[tmp] = code % n;
    code /= n;
    tmp++;
  }
}

__device__ void devPrintArray(int *dev, int n) {
  printf("[");
  for (int a = 0; a < n; a++) {
    printf("%d", dev[a]);
    if (a + 1 < n) printf(", ");
  }
  printf("]\n");
}

__device__ bool devAreNeighbors(const CuGraph &G, int a, int b) { return G.devMatrix[a * G.n + b]; }

__device__ int devGetFirstNeighbor(const CuGraph &G, int a) { return G.devFirstNeighbor[a]; }

__device__ int devGetNextNeighbor(const CuGraph &G, int a, int b) {
  int ret = G.devNextNeighbor[a * G.n + b];
  if (ret == -2) {
    assert("CUDA devGetNextNeighbor failed" == 0);
  }

  return ret;
}

__device__ bool devIsDistinctValues(int *path, int length) {
  for (int i = 1; i < length; i++) {
    for (int j = 0; j < i; j++) {
      if (path[i] == path[j]) return false;
    }
  }

  return true;
}

__device__ bool devIsAPath(const CuGraph &G, int *path, int length, bool isCycleOk = false,
                           bool areChordsOk = false) {
  if (length <= 0) return false;

  if (!devIsDistinctValues(path, length)) return false;

  for (int i = length - 1; i > 0; i--) {
    for (int j = 0; j < i; j++) {
      if (j == i - 1) {
        if (!devAreNeighbors(G, path[i], path[j])) return false;
      } else if (!areChordsOk) {
        if (isCycleOk && i == length - 1 && j == 0) continue;
        if (devAreNeighbors(G, path[i], path[j])) return false;
      }
    }
  }

  return true;
}

__device__ bool devNextPathInPlace(const CuGraph &G, int *v, int &lenV, int lenPath, bool isCycleOk = false,
                                   bool areChordsOk = false) {
  if (lenPath <= 1) {
    assert(false);  //(DEV ERROR) Length of next path must be at least 2
  }

  if (lenV > 0 && !devIsAPath(G, v, lenV, isCycleOk, areChordsOk)) {
    assert(false);  //(DEV ERROR) Input of devNextPath should be a path
  }

  if (lenV == 0) {
    v[0] = 0;
    lenV = 1;
  }

  while (true) {
    if (v[lenV - 1] == -1) {
      lenV--;
      if (lenV == 1) {
        v[0]++;
        if (v[0] >= G.n) {
          lenV = 0;
          return;
        }
        continue;
      } else {
        v[lenV - 1] = devGetNextNeighbor(G, v[lenV - 2], v[lenV - 1]);
        continue;
      }
    }

    if (lenV < lenPath) {
      v[lenV] = devGetFirstNeighbor(G, v[lenV - 1]);
      lenV++;
      if (lenV == lenPath && devIsAPath(G, v, lenV, isCycleOk, areChordsOk))
        return;
      else
        continue;
    }

    do {
      v[lenV - 1] = devGetNextNeighbor(G, v[lenV - 1], v[lenV - 1]);
    } while (v[lenV] != -1 && !devIsAPath(G, v, lenV, isCycleOk, areChordsOk));

    if (v[lenV - 1] == -1) continue;

    return;
  }
}

bool cuContainsHoleOfSize(const CuGraph &G, int size, context_t &context) {
  static const int max_size = 30;

  assert(max_size > size);

  int maxThreads = 100000;
  int k = G.n;
  int kCounter = 1;
  while (k * G.n <= maxThreads && kCounter < size) {
    k *= G.n;
    kCounter++;
  }

  cout << kCounter << endl;
  cout << k << endl;

  transform(
      [=] MGPU_DEVICE(int id) {
        int path[max_size];
        devPreparePathStart(id, kCounter, G.n, path);

        for (int i = 1; i < kCounter; i++) {
          if (!devAreNeighbors(G, path[i], path[i - 1])) return;
        }
      },
      k, context);

  context.synchronize();
}