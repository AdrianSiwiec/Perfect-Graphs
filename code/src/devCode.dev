#include "commons.h"
#include "cuCommons.h"
#include "oddHoles.h"
#include "testCommons.h"

// README
// Due to performance constraints and ease of building, all __device__ code is located in a single file

__device__ void devPrintArray(int *dev, int n) {
  printf("[");
  for (int a = 0; a < n; a++) {
    printf("%d", dev[a]);
    if (a + 1 < n) printf(", ");
  }
  printf("]\n");
}

__device__ bool devAreNeighbors(const CuGraph &G, int a, int b) { return G.devMatrix[a * G.n + b]; }

__device__ int devGetFirstNeighbor(const CuGraph &G, int a) { return G.devFirstNeighbor[a]; }

__device__ int devGetNextNeighbor(const CuGraph &G, int a, int b) {
  int ret = G.devNextNeighbor[a * G.n + b];
  if (ret == -2) {
    printf("Dev Get Next Neighbor failed, a=%d, b=%d\n", a, b);
    assert("CUDA devGetNextNeighbor failed" == 0);
  }

  return ret;
}

__device__ bool devIsDistinctValues(int *path, int length) {
  for (int i = 1; i < length; i++) {
    for (int j = 0; j < i; j++) {
      if (path[i] == path[j]) return false;
    }
  }

  return true;
}

__device__ bool devIsAPath(const CuGraph &G, int *path, int length, bool isCycleOk = false,
                           bool areChordsOk = false) {
  if (length <= 0) return false;

  if (!devIsDistinctValues(path, length)) return false;

  for (int i = length - 1; i > 0; i--) {
    for (int j = 0; j < i; j++) {
      if (j == i - 1) {
        if (!devAreNeighbors(G, path[i], path[j])) return false;
      } else if (!areChordsOk) {
        if (isCycleOk && i == length - 1 && j == 0) continue;
        if (devAreNeighbors(G, path[i], path[j])) return false;
      }
    }
  }

  return true;
}

__device__ bool devIsAHole(const CuGraph &G, int *v, int lenV) {
  return lenV > 3 && devIsAPath(G, v, lenV, true, false) && devAreNeighbors(G, v[0], v[lenV - 1]);
}

__device__ void devPreparePathStart(int code, int *v, int lenV, int n) {
  int tmp = 0;

  while (tmp < lenV) {
    v[tmp] = code % n;
    code /= n;
    tmp++;
  }
}

__device__ bool devNextPathInPlace(const CuGraph &G, int *v, int &lenV, int lenPath, bool isCycleOk = false,
                                   bool areChordsOk = false) {
  if (lenPath <= 1) {
    assert("(DEV ERROR) Length of next path must be at least 2" == 0);
  }

  if (lenV > 0 && !devIsAPath(G, v, lenV, isCycleOk, areChordsOk)) {
    assert("(DEV ERROR) Input of devNextPath should be a path" == 0);
  }

  if (lenV == 0) {
    v[0] = 0;
    lenV = 1;
  }

  while (true) {
    if (v[lenV - 1] == -1) {
      lenV--;
      if (lenV == 1) {
        v[0]++;
        if (v[0] >= G.n) {
          lenV = 0;
          return;
        }
        continue;
      } else {
        v[lenV - 1] = devGetNextNeighbor(G, v[lenV - 2], v[lenV - 1]);
        continue;
      }
    }

    if (lenV < lenPath) {
      v[lenV] = devGetFirstNeighbor(G, v[lenV - 1]);
      lenV++;
      if (lenV == lenPath && devIsAPath(G, v, lenV, isCycleOk, areChordsOk)) {
        return;
      } else {
        continue;
      }
    }

    do {
      v[lenV - 1] = devGetNextNeighbor(G, v[lenV - 2], v[lenV - 1]);
    } while (v[lenV - 1] != -1 && !devIsAPath(G, v, lenV, isCycleOk, areChordsOk));

    if (v[lenV - 1] == -1) continue;

    return;
  }
}

__device__ bool devContainsHoleWithPrefix(const CuGraph &G, int *v, int lenV, int size) {
  if (!devIsAPath(G, v, lenV, lenV == size)) return false;

  int inLenV = lenV;

  int mem = v[inLenV - 1];

  if (lenV < size) {
    devNextPathInPlace(G, v, lenV, size, true);
  }

  while (lenV == size && v[inLenV - 1] == mem) {
    if (devIsAHole(G, v, size)) {
      return true;
    }
    devNextPathInPlace(G, v, lenV, size, true);
  }

  return false;
}

__device__ bool devContainsHoleWithPrefixCode(const CuGraph &G, int code, int codeLen, int codeMax,
                                              int size) {
  static const int max_size = 30;
  assert(max_size > size);

  if (code >= codeMax) return;

  int v[max_size];
  devPreparePathStart(code, v, codeLen, G.n);
  int lenV = codeLen;

  return devContainsHoleWithPrefix(G, v, lenV, size);
}

// # cu* portion (ran by host, uses __device__ code)

bool cuContainsHoleOfSize(const CuGraph &G, int size, context_t &context,
                          int maxThreads = _max_threads_to_run) {
  int k = G.n;
  int kCounter = 1;
  while (k * G.n <= maxThreads && kCounter < size) {
    k *= G.n;
    kCounter++;
  }

  int *devOddHoleFound;
  CUCHECK(cudaMalloc(&devOddHoleFound, sizeof(int) * 1));

  // typedef launch_params_t<256, 16> launch_t;
  // cout << k << endl;
  // auto f = [=] MGPU_DEVICE(int tid, int cta) {
  //   typedef typename launch_t::sm_ptx params_t;
  //   enum { nt = params_t::nt, vt = params_t::vt };

  //   int codeStart = ((cta * nt) + tid) * vt;

  //   for (int i = 0; i < vt; i++) {
  //     int id = codeStart + i;

  //     if (devContainsHoleWithPrefixCode(G, id, kCounter, k, size)) {
  //       devOddHoleFound[0] = 1;
  //       return;
  //     }
  //   }
  // };

  // cta_transform<launch_t>(f, k, context);
  // context.synchronize();

  transform(
      [=] MGPU_DEVICE(int id) {
        if (devContainsHoleWithPrefixCode(G, id, kCounter, k, size)) {
          devOddHoleFound[0] = 1;
        }
      },
      k, context);
  context.synchronize();

  int oddHoleFound[1];
  CUCHECK(cudaMemcpy(oddHoleFound, devOddHoleFound, sizeof(int) * 1, cudaMemcpyDeviceToHost));
  context.synchronize();

  return oddHoleFound[0];
}

bool cuContainsHoleOfSize2(const Graph &G, int size, context_t &context) {
  int minPrefixes = 1000000;
  int threadsToRun = 10000000;

  int pathLen = 2;
  vec<vec<int>> prefixes;
  vec<int> v;

  do {
    pathLen++;
    prefixes = vec<vec<int>>();
    v = vec<int>();

    do {
      nextPathInPlace(G, v, pathLen, pathLen == size);
      prefixes.push_back(v);
    } while (!v.empty());
    prefixes.pop_back();
  } while (pathLen < size && prefixes.size() < minPrefixes);

  CuGraph CG(G, context);
  int *devPaths;
  CUCHECK(cudaMalloc(&devPaths, sizeof(int) * size * prefixes.size()));
  for (int i = 0; i < prefixes.size(); i++) {
    assert(prefixes[i].size() == pathLen);
    CUCHECK(cudaMemcpy(devPaths + size * i, prefixes[i].data(), prefixes[i].size() * sizeof(int),
                       cudaMemcpyHostToDevice));
  }

  int *devOddHoleFound;
  CUCHECK(cudaMalloc(&devOddHoleFound, sizeof(int) * 1));
  transform([=] MGPU_DEVICE(int id) { devOddHoleFound[0] = 0; }, 1, context);
  context.synchronize();

  transform(
      [=] MGPU_DEVICE(int id, int prefixesSize) {
        for (int i = id; i < prefixesSize; i += threadsToRun) {
          if (devContainsHoleWithPrefix(CG, devPaths + size * i, pathLen, size)) {
            devOddHoleFound[0] = 1;
            return;
          }
        }
      },
      threadsToRun, context, prefixes.size());
  context.synchronize();

  int oddHoleFound[1];
  CUCHECK(cudaMemcpy(oddHoleFound, devOddHoleFound, sizeof(int) * 1, cudaMemcpyDeviceToHost));
  context.synchronize();

  CUCHECK(cudaFree(devPaths));
  CUCHECK(cudaFree(devOddHoleFound));
  return oddHoleFound[0];
}

bool cuContainsOddHoleNaive(const CuGraph &G, context_t &context, int maxThreads = _max_threads_to_run) {
  for (int size = 5; size <= G.n; size += 2) {
    if (cuContainsHoleOfSize(G, size, context, maxThreads)) return true;
  }

  return false;
}

bool cuContainsOddHoleNaive2(const Graph &G, context_t &context, int maxThreads = _max_threads_to_run) {
  for (int size = 5; size <= G.n; size += 2) {
    if (cuContainsHoleOfSize2(G, size, context)) return true;
  }

  return false;
}

bool cuIsPerfectNaive(const Graph &G, context_t &context, int maxThreads = _max_threads_to_run) {
  standard_context_t c2(0);

  // CuGraph CG = CuGraph(G, c2);
  // CuGraph CCG = CuGraph(G.getComplement(), c2);

  // bool res = !cuContainsOddHoleNaive(CG, c2, maxThreads) && !cuContainsOddHoleNaive(CCG, c2, maxThreads);
  bool res = !cuContainsOddHoleNaive2(G, c2, maxThreads) &&
             !cuContainsOddHoleNaive2(G.getComplement(), c2, maxThreads);

  // CG.deleteCuGraph();
  // CCG.deleteCuGraph();

  c2.synchronize();

  return res;
}