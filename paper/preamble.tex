\usepackage{appendix}
\usepackage{todonotes}
\usepackage{wrapfig}
\usepackage{intcalc}
\usepackage{amsthm, amsfonts, thmtools, amsmath,amssymb}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{floatflt}
\usepackage{pgfplots}
\usepackage{enumerate}
\usepackage{subcaption}
\usepackage{expl3}
\usepackage{xparse}

\usepackage{tikz}
\tikzset{
    simplegraph/.style={every node/.style={draw,circle, inner sep=0pt, minimum size=6mm}},
}
\usetikzlibrary{snakes}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{positioning, fit, calc}
\usepackage{tkz-graph}

\usepackage[
	style=numeric
]{biblatex}
\addbibresource{bbl.bib}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{defn}{Definition}[chapter]
\renewcommand{\listtheoremname}{List of definitions}
\newtheoremstyle{break}
  {\topsep}{\topsep}%
  {\itshape}{}%
  {\bfseries}{}%
  {\newline}{}%
\theoremstyle{break}
\newtheorem{alg}{Algorithm}[section]
\newcommand*{\myproofname}{Begin}
\newenvironment{algtext2}[1][\myproofname]{\begin{proof}[#1] $ $\newline \renewcommand*{\qedsymbol}{\(End\)}}{\end{proof}}

\newcommand{\TODO}{\todo[inline]}
% \newcommandLovász{Lovász}
\newcommand\T{\mathcal{T}}
\crefname{lemma}{Lemma}{Lemmas}

\definecolor{c1}{RGB}{55,126,184}
\definecolor{c2}{RGB}{255,127,0}
\definecolor{c3}{RGB}{77,175,74}


%For the appendix
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{placeins}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\newcommand\crule[3][black]{\textcolor{#1}{\rule{#2}{#3}}}
% \usepackage{hyperref} 
\usetikzlibrary{arrows}
\usepackage[linesnumbered,vlined,ruled,algosection]{algorithm2e}

\newcommand{\mysemi}{\;}
\let\mysemisemi\;
\newenvironment{mynameforalgorithm}{%
    \begin{algorithm}%
}{%
    \end{algorithm}%
    \ignorespacesafterend%
}
\let\mynameforalgorithm\algorithm
\let\endmynameforalgorithm\endalgorithm
\let\listofalgorithms\mynameforlistofalgorithms

\usepackage{algorithm,algpseudocode}

\usepackage{amssymb}
\usepackage{graphicx}
 \usepackage{color}
 \usepackage{transparent}
 \usepackage{amssymb,stackengine}

% \definecolor{c1}{HTML}{8D75A0}
% \definecolor{c2}{HTML}{8B9CD6}
% \definecolor{c3}{HTML}{F4F1BB}
% \definecolor{c4}{HTML}{DB9D47}
% \definecolor{c5}{HTML}{FF784F}

\graphicspath{ {./img/} }

\SetNlSty{}{}{}
\SetKwInput{KwData}{Input}
\SetKwInput{KwResult}{Output}
\DontPrintSemicolon
\newcommand{\NULL}{\textsc{null}}
\SetAlgoVlined
\LinesNumbered

\SetKwBlock{IfNoEnd}{if}{}
\SetKwBlock{IfNoBegin}{}{End}

\let\oldnl\nl% Store \nl in \oldnl
\newcommand\nonl{\renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line
\newcommand{\pushline}{\Indp}% Indent
\newcommand{\popline}{\Indm}% Undent

\newcommand{\Assert}[2][]{\nonl ASSERT: #2 \ifthenelse{\equal{#1}{}}{}{(as in #1)} \; }
% \newcommand{\Assert}[2][]{}
% \newcommand{\TODO}[1]{\nonl \textcolor{red}{\# TODO:} #1 \;}

\newcommand{\mycbox}[1]{\tikz{\path[draw=white,fill=white] (0,0) rectangle (8cm,.5cm);}}
\newcommand{\mycboxx}[1]{\tikz{\path[draw=red,fill=white] (0,0) rectangle (.5cm,.8cm);}}

\newcommand{\unfinishedAlg}[2][]{
\begin{minipage}[t]{\textwidth}
\vspace{0pt} 
\begin{mynameforalgorithm}[H]
#2
\end{mynameforalgorithm}
\vspace*{#1}
\mycbox{}
\end{minipage}
}

\SetKwFor{GreyWhile}{\transparent{0.4}{// while}}{\transparent{0.4}{do}}{}
\SetKwFor{GreyWhile}{\transparent{0.4}{// while}}{\transparent{0.4}{do}}{}
\SetKwIF{GreyIf}{GreyElseIf}{GreyElseAnother}{\transparent{0.4}{// if}}{\transparent{0.4}{then}}{\transparent{0.4}{// else if}}{\transparent{0.4}{else}}{}
\SetKwIF{GreyElse}{GreyElseIfDummy}{GreyElseAnotherDummy}{\transparent{0.4}{// else}}{}{}{}{}

% \newlength\foo
\newcommand{\continueAlg}[2][]{
	\begin{minipage}[t]{\textwidth}
    \vspace{0pt} 
% \settoheight\foo{ % for some reason doesn't work. leave for now.
    \begin{mynameforalgorithm}[H]
    #2
		\end{mynameforalgorithm}
% }
    \vspace*{#1}
    \mycboxx{}
    \vspace*{-#1}
		\end{minipage}
}

\newcommand{\LGBSK}{$L(BS(K_4))$}
\newcommand{\xor}{\veebar}
\newcommand{\nsquare}{\ensurestackMath{\stackinset{c}{}{c}{}{/}{\square}}}
\newcommand{\setComplete}{\ \blacksquare\ }
\newcommand{\setAntiComplete}{\ \nsquare\ }
\newcommand{\graphAppendix}[1]{
  \begin{alg}[#1]
  \end{alg}
  \vspace{-.8cm}
}


%%%%% Hypercube

\ExplSyntaxOn

\int_new:N \l__binp_int
\int_set:Nn \l__binp_int {4}
\tl_new:N \l__bina_tl
\tl_new:N \l__binb_tl
\tl_new:N \l__binhw_tl
\int_new:N \l__bina_int
\int_new:N \l__binb_int
\int_new:N \l__binc_int
\int_new:N \l__bind_int
\fp_new:N \l__bina_fp

\DeclareDocumentCommand \BinaryPrecision {m}
{
  \int_set:Nn \l__binp_int {#1}
}

\cs_new_nopar:Npn \int_to_bin:Nn #1#2
{
  \tl_clear:N #1
  \int_set:Nn \l__bina_int {#2}
  \prg_replicate:nn {\l__binp_int}
  {
    \int_set:Nn \l__binb_int {\int_mod:nn {\l__bina_int} {2}}
    \tl_put_left:Nx #1 {\int_use:N \l__binb_int}
    \int_set:Nn \l__bina_int {\int_div_truncate:nn {\l__bina_int} {2}}
  }
}

\cs_new_nopar:Npn \bin_hamming_weight:NN #1#2
{
  \tl_set_eq:NN \l__binhw_tl #2
  \tl_replace_all:Nnn \l__binhw_tl {0} {}
  \int_set:Nn #1 {\tl_count:N \l__binhw_tl}
}

\cs_new_nopar:Npn \bin_flip_one:NNn #1#2#3
{
  \tl_set_eq:NN #2#1
  \prg_replicate:nn {#3 - 1}
  {
    \tl_replace_once:Nnn #2 {1} {a}
  }
  \tl_replace_once:Nnn #2 {1} {0}
  \tl_replace_all:Nnn #2 {a} {1}
}

\DeclareDocumentCommand \HammingWeight {m m}
{
  \int_to_bin:Nn \l__binhw_tl {#2}
  \bin_hamming_weight:NN #1 \l__binhw_tl
}

\DeclareDocumentCommand \HyperCube {m}
{
  \int_set:Nn \l__binp_int {#1}
  \int_zero_new:c {l__hyper_0_int}
  \int_set:cn {l__hyper_0_int} {-1}
  \int_step_inline:nnnn {1} {1} {#1}
  {
    \int_zero_new:c {l__hyper_##1_int}
    \int_set:cn  {l__hyper_##1_int} {\int_use:c {l__hyper_\int_eval:n {##1 - 1}_int} * (#1 - ##1 + 1) / ##1}
  }
  \fp_set:Nn \l__bina_fp {2^{#1}-1}
  \int_set:Nn \l__binc_int {\fp_to_int:N \l__bina_fp}
  \int_step_inline:nnnn {0} {1} {\l__binc_int}
  {
    \int_to_bin:Nn \l__bina_tl {##1}
    \bin_hamming_weight:NN \l__binb_int \l__bina_tl
    \node[every~ hypercube~ label/.try] (hg- \l__bina_tl) at (\int_use:c {l__hyper_\int_use:N \l__binb_int _int}/2,\int_use:N \l__binb_int) {};
    \int_incr:c {l__hyper_\int_use:N \l__binb_int _int}
    \int_incr:c {l__hyper_\int_use:N \l__binb_int _int}
  }
  \int_step_inline:nnnn {0} {1} {\l__binc_int}
  {
    \int_to_bin:Nn \l__bina_tl {##1}
    \bin_hamming_weight:NN \l__binb_int \l__bina_tl
    \int_step_inline:nnnn {1} {1} {\l__binb_int}
    {
      \bin_flip_one:NNn \l__bina_tl \l__binb_tl {####1}
      \draw[every~ hypercube~ edge/.try] (hg- \l__bina_tl) -- (hg- \l__binb_tl);
    }
  }
}

\ExplSyntaxOff