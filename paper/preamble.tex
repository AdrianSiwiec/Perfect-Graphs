% \usepackage[T1]{fontenc}
\usepackage{appendix}
\usepackage{todonotes}
\usepackage{wrapfig}
\usepackage{intcalc}
\usepackage{amsthm, amsfonts, thmtools, amsmath,amssymb}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{floatflt}
\usepackage{pgfplots}
\usepackage{enumerate}
\usepackage{subcaption}
\usepackage{expl3}
\usepackage{xparse}
\usepackage{blindtext}

\usepackage{tikz}
\tikzset{
  simplegraph/.style={every node/.style={draw,circle, inner sep=0pt, minimum size=6mm}},
}
\usetikzlibrary{snakes}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{positioning, fit, calc}
\usetikzlibrary{arrows.meta}
\usepackage{tkz-graph}

\usepackage[
  style=numeric
]{biblatex}
\addbibresource{bbl.bib}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{defn}{Definition}[chapter]
\newtheorem{defnTwo}{Definition}[chapter]
\renewcommand{\listtheoremname}{List of definitions}
\newtheoremstyle{break}
{\topsep}{\topsep}%
{\itshape}{}%
{\bfseries}{}%
{\newline}{}%
\theoremstyle{break}
\newtheorem{alg}{Algorithm}[section]
\newcommand*{\myproofname}{Begin}
\newenvironment{algtext2}[1][\myproofname]{\begin{proof}[#1] $ $\newline \renewcommand*{\qedsymbol}{\(End\)}}{\end{proof}}

\newcommand{\TODO}{\todo[inline]}
% \newcommandLovász{Lovász}
\newcommand\T{\mathcal{T}}
\crefname{lemma}{Lemma}{Lemmas}

\definecolor{c1}{RGB}{55,126,184}
\definecolor{c2}{RGB}{255,127,0}
\definecolor{c3}{RGB}{77,175,74}


%For the appendix
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{placeins}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage[utf8]{inputenc}

\usepackage{xcolor}
\newcommand\crule[3][black]{\textcolor{#1}{\rule{#2}{#3}}}
% \usepackage{hyperref} 
\usetikzlibrary{arrows}
\usepackage[linesnumbered,vlined,algosection]{algorithm2e}

\newcommand{\mysemi}{\;}
\let\mysemisemi\;
% \newenvironment{mynameforalgorithm}{%
%   \begin{algorithm}%
%     }{%
%   \end{algorithm}%
%   \ignorespacesafterend%
% }
\let\mynameforalgorithm\algorithm
\let\endmynameforalgorithm\endalgorithm
\let\listofalgorithms\mynameforlistofalgorithms

\usepackage{algorithm}
\usepackage{algpseudocode}

\let\myWhile\While
\let\EndmyWhile\EndWhile
\makeatletter
% This is the vertical rule that is inserted
\def\therule{\makebox[\algorithmicindent][l]{\hspace*{.5em}\vrule height .75\baselineskip depth .25\baselineskip}}%

\newtoks\therules% Contains rules
\therules={}% Start with empty token list
\def\appendto#1#2{\expandafter#1\expandafter{\the#1#2}}% Append to token list
\def\gobblefirst#1{% Remove (first) from token list
  #1\expandafter\expandafter\expandafter{\expandafter\@gobble\the#1}}%
\def\LState{\State\unskip\the\therules}% New line-state
\def\ls{\State\unskip\the\therules}% New line-state
\def\lsx{\Statex\unskip\the\therules~~}% New line-state
\def\pushindent{\appendto\therules\therule}%
\def\popindent{\gobblefirst\therules}%
\def\printindent{\unskip\the\therules}%
\def\printandpush{\printindent\pushindent}%
\def\popandprint{\popindent\printindent}%
\algdef{SE}[MYWHILE]{mWhile}{mEndWhile}[1]
{\printandpush\algorithmicwhile\ #1\ \algorithmicdo}
{\popandprint\algorithmicend\ \algorithmicwhile}%

\algdef{SE}[FOR]{mFor}{mEndFor}[1]
{\printandpush\algorithmicfor\ #1\ \algorithmicdo}
{\popandprint\algorithmicend\ \algorithmicfor}%

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{SE}[FOR]{mForEach}{mEndFor}[1]
{\printandpush\algorithmicforeach\ #1\ \algorithmicdo}
{\popandprint\algorithmicend\ \algorithmicfor}%

\algdef{SE}[PROCEDURE]{mProcedure}{mEndProcedure}[2]
{\printandpush\algorithmicprocedure\ \textproc{#1}\ifthenelse{\equal{#2}{}}{}{(#2)}}%
{\popandprint\algorithmicend\ \algorithmicprocedure}%
\algdef{C}[IF]{IF}{mElsIf}[1]
{\popandprint\pushindent\algorithmicelse\ \algorithmicif\ #1\ \algorithmicthen}%
\algdef{Ce}[ELSE]{IF}{mElse}{mEndIf}
{\popandprint\pushindent\algorithmicelse}%
\algdef{SE}[IF]{mIf}{mEndIf}[1]
{\printandpush\algorithmicif\ #1\ \algorithmicthen}
{\popandprint\algorithmicend\ \algorithmicif}%

\algnewcommand{\algorithmicand}{\textbf{ and }}
\algnewcommand{\algorithmicor}{\textbf{ or }}
\algnewcommand{\OR}{\algorithmicor}
\algnewcommand{\AND}{\algorithmicand}
\algnewcommand{\TRUE}{\textsc{true}}
\algnewcommand{\FALSE}{\textsc{false}}
\algnewcommand{\UND}{\textsc{undefined}}
\algnewcommand{\RETURN}{\textbf{return}~}
\algrenewcommand\algorithmiccomment[1]{\hfill \textsc{\textbackslash\textbackslash} #1}

\newcommand\fs@nobottomruled{\def\@fs@cfont{\bfseries}\let\@fs@capt\floatc@ruled
  \def\@fs@pre{height.8pt depth0pt \kern2pt}%
  \def\@fs@post{}% Formerly \def\@fs@post{\kern2pt\hrule\relax}%
  \def\@fs@mid{\kern2pt\kern2pt}%
  \let\@fs@iftopcapt\iftrue}

\floatstyle{nobottomruled}
\restylefloat{algorithm}

\makeatother

\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage{transparent}
\usepackage{amssymb,stackengine}

% \definecolor{c1}{HTML}{8D75A0}
% \definecolor{c2}{HTML}{8B9CD6}
% \definecolor{c3}{HTML}{F4F1BB}
% \definecolor{c4}{HTML}{DB9D47}
% \definecolor{c5}{HTML}{FF784F}

\graphicspath{ {./img/} }

\SetNlSty{}{}{}
\SetKwInput{KwData}{Input}
\SetKwInput{KwResult}{Output}
\DontPrintSemicolon
\newcommand{\NULL}{\textsc{null}}
\SetAlgoVlined
\LinesNumbered

\SetKwBlock{IfNoEnd}{if}{}
\SetKwBlock{IfNoBegin}{}{End}

\let\oldnl\nl% Store \nl in \oldnl
\newcommand\nonl{\renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line
\newcommand{\pushline}{\Indp}% Indent
\newcommand{\popline}{\Indm}% Undent

\newcommand{\Assert}[2][]{\nonl ASSERT: #2 \ifthenelse{\equal{#1}{}}{}{(as in #1)} \; }
% \newcommand{\Assert}[2][]{}
% \newcommand{\TODO}[1]{\nonl \textcolor{red}{\# TODO:} #1 \;}

\newcommand{\mycbox}[1]{\tikz{\path[draw=white,fill=white] (0,0) rectangle (8cm,.5cm);}}
\newcommand{\mycboxx}[1]{\tikz{\path[draw=red,fill=white] (0,0) rectangle (.5cm,.8cm);}}

\newcommand{\unfinishedAlg}[2][]{
  \begin{minipage}[t]{\textwidth}
    \vspace{0pt}
    \begin{mynameforalgorithm}[H]
      #2
    \end{mynameforalgorithm}
    \vspace*{#1}
    \mycbox{}
  \end{minipage}
}

\SetKwFor{GreyWhile}{\transparent{0.4}{// while}}{\transparent{0.4}{do}}{}
\SetKwFor{GreyWhile}{\transparent{0.4}{// while}}{\transparent{0.4}{do}}{}
\SetKwIF{GreyIf}{GreyElseIf}{GreyElseAnother}{\transparent{0.4}{// if}}{\transparent{0.4}{then}}{\transparent{0.4}{// else if}}{\transparent{0.4}{else}}{}
\SetKwIF{GreyElse}{GreyElseIfDummy}{GreyElseAnotherDummy}{\transparent{0.4}{// else}}{}{}{}{}

% \newlength\foo
\newcommand{\continueAlg}[2][]{
  \begin{minipage}[t]{\textwidth}
    \vspace{0pt}
    % \settoheight\foo{ % for some reason doesn't work. leave for now.
    \begin{mynameforalgorithm}[H]
      #2
    \end{mynameforalgorithm}
    % }
    \vspace*{#1}
    \mycboxx{}
    \vspace*{-#1}
  \end{minipage}
}

\newcommand{\LGBSK}{$L(BS(K_4))$}
\newcommand{\xor}{\veebar}
\newcommand{\nsquare}{\ensurestackMath{\stackinset{c}{}{c}{}{/}{\square}}}
\newcommand{\setComplete}{\ \blacksquare\ }
\newcommand{\setAntiComplete}{\ \nsquare\ }
\newcommand{\graphAppendix}[1]{
  \begin{alg}[#1]
  \end{alg}
  \vspace{-.8cm}
}


%%%%% Hypercube

\ExplSyntaxOn

\int_new:N \l__binp_int
\int_set:Nn \l__binp_int {4}
\tl_new:N \l__bina_tl
\tl_new:N \l__binb_tl
\tl_new:N \l__binhw_tl
\int_new:N \l__bina_int
\int_new:N \l__binb_int
\int_new:N \l__binc_int
\int_new:N \l__bind_int
\fp_new:N \l__bina_fp

\DeclareDocumentCommand \BinaryPrecision {m}
{
  \int_set:Nn \l__binp_int {#1}
}

\cs_new_nopar:Npn \int_to_bin:Nn #1#2
{
  \tl_clear:N #1
  \int_set:Nn \l__bina_int {#2}
  \prg_replicate:nn {\l__binp_int}
  {
    \int_set:Nn \l__binb_int {\int_mod:nn {\l__bina_int} {2}}
    \tl_put_left:Nx #1 {\int_use:N \l__binb_int}
    \int_set:Nn \l__bina_int {\int_div_truncate:nn {\l__bina_int} {2}}
  }
}

\cs_new_nopar:Npn \bin_hamming_weight:NN #1#2
{
  \tl_set_eq:NN \l__binhw_tl #2
  \tl_replace_all:Nnn \l__binhw_tl {0} {}
  \int_set:Nn #1 {\tl_count:N \l__binhw_tl}
}

\cs_new_nopar:Npn \bin_flip_one:NNn #1#2#3
{
  \tl_set_eq:NN #2#1
  \prg_replicate:nn {#3 - 1}
  {
    \tl_replace_once:Nnn #2 {1} {a}
  }
  \tl_replace_once:Nnn #2 {1} {0}
  \tl_replace_all:Nnn #2 {a} {1}
}

\DeclareDocumentCommand \HammingWeight {m m}
{
  \int_to_bin:Nn \l__binhw_tl {#2}
  \bin_hamming_weight:NN #1 \l__binhw_tl
}

\DeclareDocumentCommand \HyperCube {m}
{
  \int_set:Nn \l__binp_int {#1}
  \int_zero_new:c {l__hyper_0_int}
  \int_set:cn {l__hyper_0_int} {-1}
  \int_step_inline:nnnn {1} {1} {#1}
  {
    \int_zero_new:c {l__hyper_##1_int}
    \int_set:cn  {l__hyper_##1_int} {\int_use:c {l__hyper_\int_eval:n {##1 - 1}_int} * (#1 - ##1 + 1) / ##1}
  }
  \fp_set:Nn \l__bina_fp {2^{#1}-1}
  \int_set:Nn \l__binc_int {\fp_to_int:N \l__bina_fp}
  \int_step_inline:nnnn {0} {1} {\l__binc_int}
  {
    \int_to_bin:Nn \l__bina_tl {##1}
    \bin_hamming_weight:NN \l__binb_int \l__bina_tl
    \node[every~ hypercube~ label/.try] (hg- \l__bina_tl) at (\int_use:c {l__hyper_\int_use:N \l__binb_int _int}/2,\int_use:N \l__binb_int) {};
    \int_incr:c {l__hyper_\int_use:N \l__binb_int _int}
    \int_incr:c {l__hyper_\int_use:N \l__binb_int _int}
  }
  \int_step_inline:nnnn {0} {1} {\l__binc_int}
  {
    \int_to_bin:Nn \l__bina_tl {##1}
    \bin_hamming_weight:NN \l__binb_int \l__bina_tl
    \int_step_inline:nnnn {1} {1} {\l__binb_int}
    {
      \bin_flip_one:NNn \l__bina_tl \l__binb_tl {####1}
      \draw[every~ hypercube~ edge/.try] (hg- \l__bina_tl) -- (hg- \l__binb_tl);
    }
  }
}

\ExplSyntaxOff