\documentclass{article}

\usepackage{appendix}
\usepackage{todonotes}
\usepackage{wrapfig}

\usepackage{tikz}
\tikzset{%
    simplegraph/.style={every node/.style={draw,circle, inner sep=0pt, minimum size=6mm}},
}

\usepackage[
	style=alphabetic
]{biblatex}
\addbibresource{bbl.bib}


\newcommand{\TODO}{\todo[inline]}
\newcommand\Lovasz{Lovász }

% Language and typesetting notes:
%
% - Color, not Colour (American English)
% - Node not a Vertex of a graph

\author{Adrian Siwiec}
\date{\today{}}
\begin{document}
\begin{titlepage}
	\begin{center}
        
		\large
		\textbf{Jagiellonian University}\\
		Department of Theoretical Computer Science\\

		\vspace{1.5cm}

		\Large
		\textbf{Adrian Siwiec}

		\vspace*{2cm}

		\textbf{\LARGE Perfect Graph Recognition and Coloring}
		
		\vspace{0.5cm}
		\large
		
		\vfill
		\Large
		Master Thesis

		\vfill
		\Large
		Supervisor: dr inż. Krzysztof Turowski
		
		\vspace{0.8cm}
		
		September 2020
		
\end{center}
\end{titlepage}

\pagebreak

\begin{abstract}
TODO
\end{abstract}

\tableofcontents

\pagebreak

\section{Perfect Graphs}
All graphs in this paper are finite, undirected and have no loops or parallel edges. We denote the chromatic number of graph $G$ by $\chi(G)$ and the cardinality of the largest clique of $G$ by $\omega(G)$. \emph{Coloring} of a graph means assigning every node of a graph a color. A coloring is \emph{valid} iff every two nodes sharing an edge have different colors. An \emph{optimal} coloring (if exists) is a valid coloring using only $\omega(G)$ colors.

Given a graph $G = (V,E)$, sometimes by $V(G)$ and $E(G)$ we will denote a set of nodes and edges of $G$. Given a set $X \subseteq V$ by $G[X]$ we will denote a graph induced on $X$. A graph $G$ is \emph{perfect} iff for all $X \subseteq V(G)$ we have $\chi(G[X]) = \omega(G[X])$.

\TODO{Give some examples why are these interesting, some subclasses, and problems that are solvable for perfect graphs, including recognition and coloring}

Given a graph $G$, its \emph{complement} $\overline{G}$ is a graph with the same vertex set and in which two distinct nodes $u, v$ are connected in $\overline{G}$ iff they are not connected in $G$. For example a clique in a graph becomes an independent set in its complement. A perfect graph theorem, first conjured by Berge in 1961 \cite{CB61} and then proven by \Lovasz in 1972 \cite{LL72} states that a graph is perfect iff its complement graph is also perfect. \todo{Should we give some proof of that here? Maybe based on proof in \cite{GC03}}

A \emph{hole} is an induced chordless cycle of length at least 4. An \emph{antihole} is an induced subgraph whose complement is a hole. A \emph{Berge} graph is a graph with no holes or antiholes of odd length.

In 1961 Berge conjured that a graph is perfect iff it is Berge in what has become known as a strong perfect graph conjecture. In 2001 Chudnovsky et al. have proven it and published the proof in an over 150 pages long paper \citetitle{MC06} \cite{MC06}. The following overview of the proof will be based on this paper and on an article withe the same name by Cornuéjols \cite{GC03}.

\subsection{Strong Perfect Graph Theorem}

Odd holes are not perfect, since their chromatic number is 3 and their largest cliques are of size 2. It is easy to see, that an odd antihole of size $n$ has a chromatic number of $\frac{n+1}{2}$ and largest cliques of size $\frac{n-1}{2}$. It is therefore clear, that if a graph is not Berge it is not perfect. To prove that every Berge graph is perfect is the proper part of the strong perfect graph theorem.

\TODO{How long and detailed overview of the proof should we provide?}

\section{Recognizing Berge Graphs}

\TODO{Cite the paper and tell this is only a short overview}

\subsection{Recognition algorithm Overview}

\TODO{Main ideas of the algorithm.}
\TODO{First we check all on $G$, then on $\overline{G}$}

\subsubsection{Simple structures}

A \emph{path} in $G$ is an induced subgraph that is connected, with at least one node, no cycle and no node of degree larger than 2 (sometimes called chordless path). The \emph{length} of a path or a cycle is the number of edges in it. \todo{Should we move these definitions elsewhere?} A \emph{triangle} in a graph is a set of three pairwise adjacent nodes.

\begin{wrapfigure}{r}{0.35\textwidth}
	\centering\begin{tikzpicture}[scale=0.7,simplegraph]
	\node(a) at (0,0) {a};
	\node(b1) at (-2,-6) {$b_1$};
	\node(b2) at (0,-4.268) {$b_2$};
	\node(b3) at (2,-6) {$b_3$};

	\node(P12) at (-2/4, -6/4) {\small$P_{12}$};
	\node(P13) at (-4/4, -12/4) {\small$P_{13}$};
	\node(P14) at (-6/4, -18/4) {\small$P_{14}$};

	\node(P32) at (2/3, -6/3) {\small$P_{32}$};
	\node(P33) at (4/3, -12/3) {\small$P_{33}$};

	\draw (b1) to (b3);
	\draw (b1) to (b2);
	\draw (b2) to (b3);

	\draw (a) to (P12);
	\draw (P12) to (P13);
	\draw (P13) to (P14);
	\draw (P14) to (b1);

	\draw (a) to (P32);
	\draw (P32) to (P33);
	\draw (P33) to (b3);

	\draw (a) to (b2);
\end{tikzpicture}
\caption{An example of a pyramid.}
\end{wrapfigure}

A \emph{pyramid} in G is an induced subgraph formed by the union of a triangle $\{b_1,b_2,b_3\}$, three paths $\{P_1, P_2, P_3\}$ and another node $a$, so that:
\begin{itemize}
	\item $\forall_{1\leq i \leq 3}$ $P_i$ is a path between $a$ and $b_i$
	\item $\forall_{1\leq i < j \leq 3}$ $a$ is the only node in both $P_i$ and $P_j$ and $b_ib_j$ is the only edge between $V(P_i)\setminus\{a\}$ and $V(P_j)\setminus\{a\}$.
	\item $a$ is adjacent to at most one of $\{b_1, b_2, b_3\}$.
\end{itemize}

It is easy to see that every graph containing a pyramid contains an odd hole.


\TODO{On recognition of pyramids.}

Recognizing simple structures (Pyramids, Jewels, T1, T2, T3).\\

Finding and Using Half-Cleaners.\\

Overview of proof of why algorithm using Half-Cleaners is correct.\\

\subsection{Implementation}

Anything interesting about algo/data structure?\\

Optimizations - Bottlenecks in performance (next path, are vectors distinct etc).\\

Validity tests - unit tests, tests of bigger parts, testing vs known answer and vs naive.

\subsection{Parallelism with CUDA (?)}

TODO

\subsection{Experiments}

Naive algorithm - brief description, bottlenecks optimizations (makes huge difference).\\

Description of tests used.\\

Results and Corollary - almost usable algorithm.



\section{Coloring Berge Graphs}

\subsection{Ellipsoid method}

Desctiption.\\

Implementation.\\

Experiments and results.\\

\subsection{Combinatorial Method}

Cite the paper.\\

On its complexity - point to appendix for pseudo-code.

\appendix
\appendixpage
\addappheadtotoc

\section{Perfect Graph Coloring algorithm}
TODO


% \bibliographystyle{alpha}
\printbibliography

\end{document}