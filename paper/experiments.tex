\section{Experiments}
\label{sec:experiments}

\subsubsection{Data sets}

Let us describe experiments and their results. All of our algorithms search for an odd hole or an odd antihole and stop when find one, or a evidence of one. Therefore, their running times are greatest with perfect graphs on the input and we decided to use mainly\todo{run some smart nonperfect tests} perfect graphs for our performance benchmarks. For every test, the vertex number were shuffled.

Below, we first present our data sets then overall time results on them and lastly a plot breaking down what parts of CCLSV and GPU CCLSV constitute their overall running time.

We ran tests on nine classes of perfect graphs.
\begin{itemize}
  \item perfect Erd\H{o}s--Rényi graphs,
  \item Random bipartite graphs,
  \item Line graphs of random bipartite graphs,
  \item Lattice graphs (\cref{fig:lattice}),
  \item Rook graphs (\cref{fig:rook}),
  \item Knight graphs (\cref{fig:knight}),
  \item Hypercube graphs (\cref{fig:hypercube}),
  \item Split graphs (\cref{fig:split}),
  \item Full binary trees.
\end{itemize}

\begin{figure}
  \input{tikzpictures/graphs.tex}
  \caption{Graph classes}
  \label{fig:graphClasses}
\end{figure}

In \Cref{fig:graphClasses} we present small examples of some of the above classes. Let us describe them briefly.

An \emph{Erd\H{o}s--Rényi} model is a method of generating random graphs. Every possible edge is included in a graph with probability $1/2$. We generated them as long as we found enough perfect graphs for each $|V|$ we wanted to test. \todo{implement generating perfect graphs by removing long cycles} This method of generating perfect graphs is very inefficient and we couldn't generate any graphs with $|V| \geq 20$. Second, those graphs favour the na\"ive algortihm, because there is very low probability of long paths to appear.

Next, we generate bipartite graphs in similar manner -- each edge between two equal sized node sets has a probability of $1/2$ to appear. We also generate line graphs of bipartite graphs. This gives us graphs of varying $|V|$, so we repeated the process until we had sufficieng number of graphs for each $|V|$.

There are also a few interesting classes of perfect graphs that appear on a grid, or a checker board. In lattice graph, each vertex is connected to vertices that are above, below, to the left and to the right of it, if such vertices exist. See \Cref{fig:lattice} for an example of a $4 \times 4$ lattice graph. If we imagine our grid to be a chessboard we can define a rook graph to have an edge, when the rook from chess can move from one vertex to another in one move. See \Cref{fig:rook} for an example of $4 \times 4$ rook graph. In similar manner we can define a knight graph (\Cref{fig:knight}).

A hypercube is a generalization of a cube to a higher dimensional space. We use hypercubes that are not complete, to achieve higher granularity of data. In a hypercube of $n$ vertices there is an edge between vertices $u$ and $v$ if and only if binary representations of $u$ and $v$ differ by exactly one bit.

\TODO{split better granulity and detailed}
Split graphs we use are unions of cliques and independent sets of same size, with some edges between them. In generating them, each edge between a vertex from a clique and a vertex from an independent set has had $1/2$ chance to appear.

Finally, we benchmark on full binary trees to see how CCLSV works with a tree as an input.

\subsubsection{Time results}

% \begin{figure}
%   \centering
%   \input{plots/perf.t.in.out.csv.lines.pgf}
%   \caption{Random perfect graphs}
%   \label{plot:perfLines}
% \end{figure}

\begin{figure}
  \centering
  \input{plots/biparite.t.in.out.csv.lines.pgf}
  \caption{TODO: redo with more data Random bipartite graphs}
  \label{plot:perf2Lines}
\end{figure}

\begin{figure}
  \centering
  \input{plots/perf2.t.in.out.csv.lines.pgf}
  \caption{Line graphs of random bipartite graphs}
  \label{plot:perf2Lines}
\end{figure}

\begin{figure}
  \centering
  \input{plots/grid6by5to11.t.in.out.csv.lines.pgf}
  \caption{Lattice graphs}
  \label{plot:gridLines}
\end{figure}

\begin{figure}
  \centering
  \input{plots/rookGraph5by4to7.t.in.out.csv.lines.pgf}
  \caption{Rook graphs}
  \label{plot:rookLines}
\end{figure}

\begin{figure}
  \centering
  \input{plots/knightGraph8by4to8.t.in.out.csv.lines.pgf}
  \caption{Knight graphs}
  \label{plot:knightLines}
\end{figure}

\begin{figure}
  \centering
  \input{plots/hypercubes20to55.t.in.out.csv.lines.pgf}
  \caption{Hypercube graphs}
  \label{plot:hypercubeLines}
\end{figure}

\begin{figure}
  \centering
  \input{plots/split20to50.t.in.out.csv.lines.pgf}
  \caption{Split graphs}
  \label{plot:splitLines}
\end{figure}

\begin{figure}
  \centering
  \input{plots/fullBinary20to100.t.in.out.csv.lines.pgf}
  \caption{Full binary trees}
  \label{plot:splitLines}
\end{figure}

\begin{figure}
  \centering
  \input{plots/detailed.csv.detailed.pgf}
  \caption{Detailed running times}
  \label{plot:splitLines}
\end{figure}





When looking at the results (\Cref{plot:perfLines}), while na\"ive algorithm's time is almost zero, we see the CCLSV running time climbing with the growth of $|V|$, with only moderate improvement by GPU CCLSV. Slight GPU improvement is explained by anylysis of the components of the overall time (\Cref{plot:perfDet}). Testing all near cleaners takes up around half of total time, so we cannot speed up the overall time by much. These are also relatively small tests, so the latency from copying data to the GPU is significant.


Next, we generated a random bipartite graphs (see paragraph above) and then calculated their line graphs. This gives us graphs of varying $|V|$, so we repeated the process until we had sufficieng number of graphs for each $|V|$. On \cref{plot:perf2Lines} we can see na\"ive algorithm being much faster on the majority of the tests, although its faster growth allows GPU CCLSV to be faster on the biggest tests.

We turn our attention to graphs generated on a grid, or a checker board (see later paragraphs). First, we take lattice graphs. In lattice graph, each vertex is connected to vertices that are above, below, to the left and to the right of it, if such vertices exist. See \cref{fig:lattice} for an example of a $4 \times 4$ lattice graph.

Let us take a look at \cref{plot:gridLines}. It is a clear example of why polynomial algorithms can be useful, even the ones with time complexity as high as CCLSV. For $|V| = 48$ the running time for the CCLSV is 22.2s, for GPU CCLSV is 7.7s and for na\"ive is 1.5s. Na\"ive is almost 15x faster. But with growing $|V|$ its running time grows very fast, reaching 41s for $|V| = 60$ and 210s for $|V| = 66$. CCLSV growth is much gentler and for $|V| = 66$ it is 2.5x faster than na\"ive.

If we imagine our grid to be a chessboard we can define a rook graph to have an edge, when the rook from chess can move from one vertex to another in one move. See \cref{fig:rook} for an example of $4 \times 4$ Rook graph.

Rook graphs have many more chords than Lattice graphs, so the na\"ive's performance is much better here. What is more interesting, the overall performance of CCLSV is much worse (\cref{plot:rookLines}). Looking at \cref{plot:rookDet} we can see that the majority of CCLSV time is spent checking all near cleaners. This can be explained by the fact that rook graphs are much denser than lattice graphs and have many more 3-vertex paths (see line TODO of \cref{alg:testNearCleaner}). This is confirmed by greater CCLSV GPU speedup of around 6x on graphs with $|V| = 35$.


A hypercube is a generalization of a cube to a higher dimensional space. We use hypercubes that are not complete, to achieve higher granularity of data. In a hypercube of $n$ vertices there is an edge between vertices $u$ and $v$ if and only if binary representations of $u$ and $v$ differ by exactly one bit.

Hypercube graphs tell a similar story to lattice graphs and knight graphs. Na\"ive algorithm is very fast at first, but becomes unbearably slow for $|V|$ higher than 55. Unfortunately, CCLSV doesn't fare much better, although it grows slower. Again, the speedup of GPU CCLSV is noticeable, being around 4.8x for $|V| = 55$.

Split graphs we use are unions of cliques and independent sets of same size, with some edges between them. In generating them, each edge between a vertex from a clique and a vertex from an independent set has had $1/2$ chance to appear.

There are no long paths here, so na\"ive algorithm works great (\cref{plot:splitLines}). What is interesting, when looking at detailed times of GPU CCLSV, we can see that checking the existence of simple forbidden structures takes more than 30\% of the time. This opens a possibility of further GPU speedups, not explored by us.

\pagebreak
\section{Coloring Berge Graphs}

\subsection{Ellipsoid method}

We used an open source CSDP \cite{csdpRepo, csdp1999} library, that implements predictor corrector variant of the semidefinite programming algorithm to calculate $\vartheta(G)$, given $G$ on the input. The CSDP library has been used in many recent publications across different fields, such as \cite{Ampountolas_2017, Adasme_2011}.

\TODO{setting $\epsilon = 1/2$ in csdp helped a lot -- how much?}

Calculating $\vartheta(G)$ is the most complicated part of the coloring algorithm. With that done by an external library, the rest of the program is a straightforward implementation of the algorithms in \cref{sec:coloringEllipsoid}. In most of our tests, the majority of running time was consumed on calculating $\vartheta$ of various graphs. As it was done by an external library, there isn't much optimization potential for us. One thing of note is, that specifying the precision of $\vartheta$ we want to calculate to be $1/3$ sped up the algorithm by TODO. Our main goal of the implementation was to check if this method is still impractical, even on modern equipment. Let us proceed straight to experiments and results.

\subsubsection{Experiments and results}

\begin{figure}
  % \begin{subfigure}{.5\textwidth}
  %   \centering
  %   \input{plots/color.perf.t.in.out.csv.lines.pgf}
  %   \caption{Random perfect graphs}
  % \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    TODO
    \caption{Random perfect graphs}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    TODO
    \caption{Line graphs of random perfect graphs}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
    \centering
    \input{plots/color.grid5by4to9.t.in.out.csv.lines.pgf}
    \caption{Lattice graphs}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \input{plots/color.rookGraph6by4to8.t.in.out.csv.lines.pgf}
    \caption{Rook graphs}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
    \centering
    \input{plots/color.knightGraph6by4to8.t.in.out.csv.lines.pgf}
    \caption{Knight graphs}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering%
    \input{plots/color.hypercube20to40.t.in.out.csv.lines.pgf}
    \caption{Hypercube graphs}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
    \centering
    TODO
    \caption{Split graphs}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    TODO
    \caption{Full binary trees}
  \end{subfigure}
\end{figure}

\begin{figure}
  \centering
  \input{plots/color.detailed.csv.detailed.pgf}
  \caption{Detailed times of coloring}
\end{figure}

A few things of note. We notice that in rook graphs the graph manipulation other than calculating CSDP takes close to half of overall running time (\cref{plot:colorRookDet}). We didn't particularly optimize this, other than by use of methods developed for Berge graph recognition algorithm. There are surely some optimizations to be made here if need be. Altough, as we can see on other plots, it won't help in majority of the cases.